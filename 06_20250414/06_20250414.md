## `std::forward` implementasyon tekrar

@00:14
# Kisaltilmis (Abreviated) Template

> C++20 ile gelen bir ozellik.

```cpp
template <typename T>
void foo(T x);

void foo(auto x);
```

```cpp
template <typename T>
void foo(T& x);

void foo(auto x);
```

```cpp
template <typename T>
void foo(T&& x);

void foo(auto&& x);
```

# Generelized Lambda

- [`forward` ornek kod](https://godbolt.org/z/eEj47hnj6)
- [Reference Qualifiers ile `forward` ornegi](https://godbolt.org/z/KzdPEfn3h) @00:35

> Universal referans parametreli fonksiyonun L value nesneleri icin cagrilmasini yasaklamak istiyorum.

# Concepts (Kisa inceleme)

```cpp
template <typename T>
requires (!std::is_lvalue_reference_v<T>)
void foo (T&& t)
{
    bar(std::forward<T>(t));
    // bar(std::move(t));
}
```

- Ayni kodun *SFINAE* ile implementasyonu (Hatali olabilir!)

```cpp
template <typename T, typename = typename std::enable_if_t<!std::is_lvalue_reference_v<T>>>
void bar (T&& arg)
{

}
```

```cpp
template <typename T>
requires std::is_vonvertible_v <T, std::string>
void foo(T&&)
{

}
```

@01:12
# auto&&

> Ne ise yariyor neden boyle bisey kullanalim? @01:16

2 onemli tema var.
  
[Onemli tema ornegi 1](https://godbolt.org/z/jqPhb79cK)

> Derleyicinin range based for loop karsiliginda yazdigi kod. @01.23

```cpp
// Pseudo code

for (auto elem : con) {
    elem
}

// Yukaridaki range based for loop icin derleyicinin yazdigi kod:

auto&& range = con;

for (auto ibeg = begin(con), iend = end(range); ibeg != iend; ++ibeg) {
    auto elem = *ibeg;
}
```

@01:30
> std::vector'un bool acilimi bool tutmuyor. Bir partial specialization. Bit tutuyor.


 - std::vector<bool> Onemli
 ## **perfect passing** @01:42
 ```cpp
// Myclass bar ();
// Myclass& bar()
// Myclass&& bar()
template <typename T>
void foo(T&& t)
{
//Myclass
//Myclass&
//Myclass&&
baz (bar (std:: forward<T>(t))); //perfect passing
}
 ```
 > `bar`in geri donus degerinin R value olmasi durumunda, `baz` a da verilecek parametre R value olur. Geri donus degerinin L value olmasi durumunda ise `baz` a gecilecek parametre L value olur. Bu duruma *perfect-passing* denir.

 ## **deferred perfect passing**

```cpp
// Myclass bar();
// Myclass& bar()
// Myclass&& bar()
//deferred perfect passing
template <typename T>
void foo(T&& t)
auto&& ret = bar (std: :forward<T>(t));
//some code here
baz (std::forward<decltype(ret)>(ret));
```

> *Perfect passing* gibi ama geri donus degerini bazi islemlerden sonra value caregorysini koruyarak pass etme durumuna ise *deferred perfect passing* denir.

 ## **perfect returning**

```cpp
//template <typename T>
//? ? ? call_foo(T&& t){
// foo(std: :forward<T>(t))
//}
```

```cpp
template <typename T>
decltype(auto) call_foo(T&& t)
foo(std: :forward<T>(t)){
}
```
> `call_foo` nun geri donus degerinin value categorysinin `foo` nun geri donus degeri value categorysine gore secilmesi. `std::invoke` kisaca bahsedildi. `std::apply` bahsedildi.

 > Kisa decltype ozeti. @01:58
 - `decltype(auto)` @02:17

@02:26
 ## **Deferred perfect returning**
 ```cpp
// deferred perfect returning
template < typename F, typename... Args>
decltype(auto) call(F&& f, Args&& ...args)
{
    //Myclass ret
    //Myclass& ret
    //Myclass&& ret
    decltype(auto) ret = f(std:: forward<Args>(args) ...);
    //
    if constexpr (std:: is_ rvalue_reference_v<decltype (ret) >) {
        return std: :move(ret);
    }
    else {
        return ret;
    }
}
 ```