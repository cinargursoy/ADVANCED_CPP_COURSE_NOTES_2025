# Perfect Forwarding
 - Forwarding Reference (Standard isimlendirme) -> Universal Reference (Scott Meyers isimlendirmesi)

 > *make* fonksiyonlarinin cogu perfect forwarding ornegidir.
 - `make_unique`

> Bir function template icin yapilacak cagrida template argumani explicit sekilde belirtilmezse, template argument deduction gerceklesir.

> Template argument deductionda cikarim parametre degiskeni icin yapilmaz, template parametresi icin yapilir.


@00.34
**Universal Referans ile Ilgili Sonuclar:**

1. Eger bir fonksiyonun parametresi universal ref ise her turlu argumani cover eder.
2. Bu durumda derleyicinin olusturacagi specializationda parametre ya R value ref ya da L value ref olur.
3. Asagidaki ornek icin fonksiyona L value parametre gonderirsek `T` L value reference olur, R value parametre gonderirsek `T` referans olmayan tur olur.
```cpp
template <typename T>
void foo (T&& param)
{
    T;
}
```

> Parametresi universal reference olan template func'larin amaci sadece perfect forwarding yapmak degildir. Baska amaclari da olabilir.

> Universal reference parametreli fonksiyonda gonderilen argumanin R value mu, L value mu oldugunu compile time'da saptayabiliyoruz. Bu da compile time'da L val'ler icin ayri R valler icin ayri kod yazabilmek demek. Ayrica const gonderilen argumanin const olup olmadigi tespit edilebilir.

1. Perfect forwarding yapmak icin
2. Value category dependend kod yazmak icin,
3. Constness dependend kod yazmak icin kullanilabilir

**Perfect Forwarding Reference olmayan durumlar:**

```cpp
template <typename T>
void foo(const T&& param) // Kesinlikle universal ref degil! const R value ref
{

}

teplate <typename T>
class Nec {
public:
    void foo(T&&); // Kesinlikle universal ref degil! Nec'in int acilimi icin bu fonk'un parametresi int&& olur.
};

/* Member fonksiyonun parametresinin universal ref olmasi icin member template olusturulmali */
template <typename T>
class Nec {
public:
    template <typename U>
    void foo(U&&);
};

template <typename T>
class Myclass {};

template <typename T>
void foo(Myclass<T>&&); // Kesinlikle universal ref degil! R value ref

template <typename T>
void foo (typename T::value_type &&x); // universal ref degil! R value ref


template <typename T>
void foo(T&&)
{

}

template<>
void foo(std::string&&) // Partial specialization.
{

}
```
Overload resolution ile ilgili onemli ornek. Partial ordering rules.@00:53

```cpp
template <typename T>
void func(T) { std::cout << "func<T>\n"; }

template <>
void func(int*) { std::cout << "func(int*)\n"; }

template <typename T>
void funct(T*) { std::cout << "func<T*>\n"; }

int main()
{
    int x{};
    func(&x);
}
```

@00:58
 ## std::forward olmadan perfect forwarding implementasyonu
 > Value category ile ilgili yardimci 2 cast fonksiyonu var:
 > 1. `std::move`: L value da alsa R value da alsa, R value dondurur.
 > 2. `std::forward`: L value alirsa L value dondurur, R value alirsa R value dondurur.

 ```cpp
template <typename T>
void call_foo(T&& t)
{
    if constexpr(std::is_lvalue_reference_t<t>) {
        foo(t);
    } else {
        foo(std::move(t));
    }
}
 ```

 ```cpp
 template <typename T>
 constexpr std::remove_reference_t<T>&& Move noexcept (T&& t)
 {
    return static_cast<std::remove_reference_t<T>&&>(t);
 }

 template <typename T>
 constexpr T&& Forward(std::remove_reference_t<T>& t) noexcept
 {
    return static_cast<T&&>(t);
 }

template <typename T>
constexpr T&& Forward(std::remove_reference_t<T>&& t) noexcept
{
    static_assert(!std::is_lvalue_reference_v<T>);
    return static_cast<T&&>(t);
}
 ```

@01:19
 ## `std::is_lvalue_reference_v` ve `std::remove_reference_t` incleme:

 > **metafunction:** Compile time'da tur veya deger hesaplamaya yonelik siniflar. Eger deger hesaplamaya yonelik bir metafunc ise; onun degeri hesaplamasi saglayan constexpr static veri elemani olan value olacak.

- integralConstant

@01:28
 ## isPointer isIntegral implementasyonu
 ```cpp
#include <type_traits>

template <typename T>
struct isPointer : std::false_type { };

template <typename T>
struct isPointer<T*> : std::true_type { };

template <typename T>
constexpr bool isPointer_v = isPointer<T>::value;
 ```

Asagidaki kod ideal hali degil, ileride anlatilacak.
 ```cpp
template <typename T>
struct is_int : std::false_type { };

typename <>
struct is_int<int> : std::true_type { };

typename <>
struct is_int<const int> : std::true_type { };

typename <>
struct is_int<volatile int> : std::true_type { };

typename <>
struct is_int<const volatile int> : std::true_type { };
 ```

@01:35
 ## isSame implementasyonu

```cpp
template <typename T, typename U>
struct isSame : std::false_type { };

template <typename T>
struct isSame <T, T> : std::true_type { };

template <typename T, typename U>
constexpr static isSame_v = isSame<T, U>::value;
```

 ## removeReference implementasyonu
 Type transformation
 
 ```cpp
template <typename T>
struct RemoveReference {
    using type = T;
};

template <typename T&>
struct RemoveReference {
    using type = T;
};

template <typename T&&>
struct RemoveReference {
    using type = T;
};
 ```
**Alias Template**

```cpp
template <typename T>
using RemoveReference_t = typename std::remove_reference<T>::type;
```
> C++'ta kac cesit template var?
1. Class template
2. Function template
3. Variable template
4. Alias template
5. Concept


 # 3 farkli template parametre category var:
  - Type parameter
  - non-type parameter
  - template template parameter

## lambda ifadeleri

@02:16
> *Conflicting parameters*

@02:38
> Parametrik yapisi copy elision olacak sekilde yazilan fonksiyonlar ile ilgili soru cevaplandi.

- Eger bir parametrenin bir kopyasi alinip, o kopya uzerinde degisiklik yapilacaksa bu parametrik yapi kullaniliyor.