# Reference Qualifiers
- Sinifin non static uye fonksiyonlarini nitelemenin bir yolu.
- Neden boyle bir niteleme istiyoruz. Cunku sunlari yapmak mumkun:
    - Bir sinifin non static uye fonksiyonu sadece L value sinif nesneleri icin cagrilsin.
    - Sadece R value nesneler icin cagrilsin.
    - Sadece `const` sinif nesneleri icin cagrilsin.

```cpp
class Nec {
public:
    void foo()&;
    void foo()&&;
    void foo() const &;
    void foo() const &&; // Neredeyse hic kullanilmiyor.
    // void foo(); Overload edilemez.
};
```

> Reference qualified olan overload'lara, reference qualified olmayan bir overload eslik edemez. @00.10

## Getter Functions

# Move-Only Types @00.41
- unique_ptr
- thread
- jthread
- ostream
- unique_lock
- shared_lock
- package_task
- future
- promise

```cpp
class MoveOnly {
public:
    MoveOnly (MoveOnly&&);
    MoveOnly& operator= (MoveOnly&&);
};
```

## Move-only type nerede kullanilabilir, nerede kullanilmalidir?
 
 > L value to X value conversion. 

 ## Iterator adapter @01.00
  - `move_iterator`

  ```cpp
  #include <iterator>
  #include <vector>
  int main()
  {
    using namespace std;
    vector<Myclass> vec(10);
    move_iterator‹vector<Myclass>:: iterator> iter(vec.begin());
    auto x = *iter; // Bu sekilde dereference edince R value nesneye erisiliyor. 
  }
  ```

  - `make_move_iter`
  > Move only type initializer list'te kullanilamiyor. Cunku copy'ye neden oluyor.
  
  > Bir sinifin bir data member'i move-only type ise ve special member functionlari implicitly declare edilmis ise, copy member functionlari derleyici tarafindan delete edilir. Bu da sinifin move-only type olmasina sebep olur. @01.30 

  @01:51
  # `noexcept` specifier ile move semantigi arasindaki iliski
  > Fonksiyonlar, ozellikle siniflarin uye fonksiyonlari exception handling acisindan su sekilde kategorize edilir:
   - no exception guarantee
   - basic exception guarantee
   - strong exception guarantee
   - no throw guarantee

   > Exception safety guaratee verilmemesi aslinda bir fonksiyon exception gonderdiginde kaynak sizintisi olabilir, ya da program artik bir valid state'te olmayabilir.

   Basic Exception Guarantee: Eger bu fonksiyonun kodu calistiginda, bir exception gonderilir ise program valid state'te kalacak ve uye fonksiyonu cagrilan nesne valid state'te olacak ve kaynak sizdirmayacak. Kaynak sizintisi olmamasini garantiliyor. Fakat nesnenin degerinin bu islem baslamadan onceki deger olacagi garantisini vermiyor.

   Strong Exception Guarantee(Commit or Roll-Back Guarantee): Ya islem basarili olacak, ama isini yapamazsa yani exception gonderirse nesnenin isini yapmadan onceki degerini koruyacak. Yani basic exception guarantee'nin butun garantilerini veriyor bir de exception olursa nesnenin fonksiyon cagrilmadan onceki state'ini koruyacagini garantiliyor. Orn: std::vector sinifinin `push_back` fonk.'u bu garantiyi veriyor.

   No Throw Guarantee: Fonksiyon exception gondermeyecegini garantiliyor.

   - `noexcept` specifier
   - `noexcept` operator

```cpp
   /* Asagidaki iki bildirim birbirine es deger */
   void foo() noexcept (true);
   void bar() noexcept;
   
   void foo() noexcept (false);
   void bar();
    
```

```cpp
    #include <type_traits>

    template < typename T>
    void foo(T)noexcept (std:: is_nothrow_move_constructible_v‹T>);
```

- `noexcept()` operatoru

Compile time operatoru. Parantez icine yazilan ifadenin yurutulmesi surecinde exception throw etmeme garantisi varsa `true` aksi halde `false` deger uretir.

```cpp
int main ()
int {x}, {y};
constexpr auto b = noexcept(x + y); /* true deger uretir */
```

@02.10
## Sinifin Implicitlt Declared Special Member Functionlarinin noexcept Durumu
Derleyici yazmasi gereken fonksiyonunu nasil yazacagini biliyor. Derleyici yazdigi kodda exception throw etmeme garantisinin saglandigini gorurse, derleyicinin implicitly declare ettgi fonksiyon `noexcept` olur.

```cpp
class Nec {

};

int main()
{
    cout << "is default constructor noexcept    : " << is _nothrow_default_constructible_v<Nec> << '\n';
    cout << "is destructor noexcept             : " << is_nothrow_destructible_v<Nec> << '\n';
    cout << "is copy ctor noexcept               : " << is_nothrow_copy_constructible_v<Nec> << '\n';
    cout << "is move ctor noexcept              : " << is_nothrow_move_constructible_v<Nec> << '\n'
    cout << "is copy assignment noexcept        : " << is_nothrow_copy_assignable_v<Nec> < '\n';
    cout << "is move assignment noexcept        : " << is_nothrow_move_assignable_v<Nec> << '\n';
}
```
> `noexcept` operatoru unevaluated contex olusturur.
> `noexcept` specifier bildirimsel bir fark yaratiyor ama function overload olusturmuyor.
 
 @02:27
## `noexcept` Fonksiyon Pointerlari
## `noexcept` Inheritence Iliskisi

@02:40
> Turemis sinif, taban sinifin sanal fonksiyonun verdigi garantiden daha azini vermeyecek. Istedigi kosullardan daha fazla kosul sunmayacak.

> Bir fonsiyonun `noexcept` olup olmamasi tasima semantigi tarafinda derleyicinin uretecegi kodu etkiliyor. Orn. `vector` sinifinin `push_back` fonksiyonu.