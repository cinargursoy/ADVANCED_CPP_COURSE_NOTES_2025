# TEMPLATES

**Template Nedir?** 

Amaci derleyiciye kod yazdirmak olan kod formudur.

> **Template Kategorileri:**
> - *function templates* (Since C++98)
> - *class templates*
> - *variable templates* (Since C++14)
> - *alias templates* (Since C++11)
> - *concepts* (Since C++20)

Yeni standartlarla template'ler konusundan bazi kisitlamalar da esnetildi. *Non Type Template Parameter* Turleri onceden sadece tam sayi, pointer ve referans turleri alabiliyorken artik gercek sayi deger ve literal type tur alabiliyor.

@00:12
## TEMPLATE PARAMETERS

Template parameter olarak kastedilen `template <??>` acisal parantez icinde tanimlanan isimlerdir.

- type parameter
- non-type parameter
- template parameter

Derleyicinin kod yazarken parametrelere karsilik kullanacagi ogeye *Template Argument* denir.

### *TYPE PARAMETER*
> `typename` ya da `class` anahtar sozcugu ile tanitilan isimlere denir.
> `template <class T>` veya `template <typename T>` seklinde. `T` yerine bir tur kullanilacak.

### *NON-TYPE PARAMETER*
> `template <int N>` Verilen turden deger kullanir.

**Sinama Sorulari**:

1) Kodda hata var mi? Kac tane template parametresi var:
```cpp
template < typename T, T x>
class Myclass {

};
```
Cevap: Hata yok. 2 template parametresi var. Ilki type, digeri non-type parametre.

2) Bu bir *template* mi degil mi? Bu parametre *type parameter* mi *non-type parameter* mi?
```cpp
void foo (auto x)
{

}
```
Cevap: Evet *template*. *type parameter*.

3) Bu gecerli bir *template* mi? Bu parametre *type parameter* mi *non-type parameter* mi?
```cpp
template <auto x>
class Myclass {

};
```
Cevap: *Non-type parameter*.


### *Template Template Parameter*
> Template parametresine karsilik kullanilacak template argumani bir tamplate.


```cpp
#include <vector>
template < template<typename, typename> typename>
class Myclass {
  
  };

int main()
{
  using namespace std;
    Myclass<vector> x;
}
```

- `std::vector` boyle bir tur.


```cpp
template < typename T, int N>
class Nec {

};

template < template < typename, int> typename T>
class Erg {

};

int main()
{
  Erg<Nec> x;
}
```

> *Template template parametre* nerelerde kullanilir: *Policy based design*, *CRTP*.



> C++20 ile *non-type parameter* `float` turu olabiliyor.


@00:37
## Temel Terimler

- template id
- template specialization
  - explicit (full) specialization
  - partial specialization
- template instantiation
  - explicit template instantiation
  - implicit template instantiation
- 
  - extern template declaration
- template argument
  - explicit template argument
- template argumaninin belirlenmesi
  - explicit template argument
  - deduction
  - defatul demplate argument
- template argument deduction
- variadic template
- template parameter pack
- templates with parameter packs
  - pack expansion
  - fold expression
    - unary fold
      - unary left-fold
      - unary right-fold
    - binary fold
- Dependent Type
- Point of Instantiation
- name lookup
  - 2-phase name lookup
- overloading of function templates
- Partial ordering Rules
- `if constexpr` // static if
- `static_assert` declaration
- `type_traits`

---

- ***Template Id***: Template'ten olusturulabilecek herhangi bir product.
```cpp
template < typename T, typename U>
class Myclass {
};
// Asagidakiler template id.
// Mclass<int, double>
// Mclass<int, int>
// Mclass<long, int>

template < typename T>
void foo(T, T);
// Asagidakiler template id.
// foo<long> (long, long)
// foo<int> (int, int)
// foo<string > (string, string)
```
- ***Template Instantiation***: Derleyicinin template'ten kod uretmesi.
  - ***Explicit Template Instantiation***: Acik acik vector sinif sablonunu int turu icin int'i template argumani olarak kullanip vectorun int specialization kodunu yaz, emrediyorum.(Temel kursta anlatilmadi.)
```cpp
template std::vector <int>
int main()
{

}
```

```cpp
template void std::swap<int>(int&, int&);
int main()
{

}
```
  - ***Implicit Template Instantiation***: Derleyicinin durumdan vazife cikarip specialization olusturmasi.
```cpp
int main()
{
  std::vector<int>
}
```
- ***Template Specialization***: Derleyicinin template'ten kod urettikten sonraki  varlik.
  - ***Explicit(Full) Specialization***: Derleyici sen bir *template id* icin olusacak *specialization*'u olusturma, ben sana olusturulmus halini veriyorum.

    ```cpp
    template <typename T>
    class Myclass {
    };

    template<>
    class Myclass<int> {
    };
    ```
   
    ```cpp
    template <typename T, typename U, int N>
    class Myclass {
    };

    template<>
    class Myclass<int, double, 5> {
    };
    ```
  - ***Partial Specialization***:
    Derleyici sonsuz farkli sayida olabilecek potansiyal specializationlardan, belirli bir specialization alt kumesi icin, senin olusturman gereken specialization'u ben sana veriyorum.
    ```cpp
    template <typename T, typename U, int N>
    class Myclass {
    };

    template < typename T>
    class Myclass<T, int, 5> {
    };
    
    // Myclass<double, int, 5›
    // Myclass<char, int, 5›
    // Myclass<string, int, 5›
    ```
- ***Template Argument***:
Template parametrelerine karsi kullanilan, template parametresinin ne olduguna bagli olarak; tur, deger ya da template'in kendisi.
  - ***Explicit Template Argument***
```cpp
   template <typename T, int N>
    class Myclass {
    };

    template < typename T>
    void foo(T, T);

    int main()
    {
      Myclass<int, 5>; // Explicit Template Argument
      foo(1, 5); // Explicit Template Argument degil!
    }
```
  - ***Template Argument Deduction***: Fonksiyona gonderilen arguman ya da argumanlardan hareketle, template parametrelerine karsilik gelecek argumanlarin belirlenmesi. Error ile sonuclanabilir.
  - ***Defatult Template Argument***
```cpp
template < typename T, typename U = T>
class Myclass{};
```
- ***Templete Parameter Pack***: Programcilar arasinda Variadic template argument de denir.
**Sinama Sorusu**: Derleyici 1 arguman kullanilirsa 1.sablonu, 2 arg icin 2.sablonu, 3 arg kullanilirsa 3. sablonu mu kullanir?

```cpp
template < typename T>
class Myclass {};

template < typename T, typename U>
class Myclass {};

template < typename T, typename U, typename Z>
class Myclass {};
```

Cevap: Sentaks hatasi. Sinif sablonlarinin overload edilmesi diye bisey yok, fonksiyon sablonlari icin mumkun. Bunu saglamak icin *Template Type Parameter Pack* kullanilir.

```cpp
template < typename ... Ts>
class Myclass {};

int main
{
  Myclass<int, double, long> x;
}
```

  - ***Templete Type Type Parameter Pack***
```cpp
emplate < typename ... Ts>
class Myclass {};
```
  - ***Templete Non-Type Type Parameter Pack***
```cpp
emplate < int ... VALS>
class Myclass {};

int main
{
  Myclass<2>
  Myclass<2, 3>
}
```
  - ***Templete Template Type Parameter Pack***
```cpp
```

- ***Non-type parametrede `auto` Kullanimi*** (Since C++17)
Non type parametre, ama type type parametreye karsilik gelen argumandan hareketle non-type parametrenin turu anlasilacak.
```cpp
template <auto N>
class Myclass {};
int main()
{
  Muclass<4> x;
  Muclass<4u> y;
  Muclass<4.5> z;
}
```

```cpp
template ‹auto ... Vals>
class Myclass {};
int main()
{
  Myclass<2, 3.4, 6U> x;
}
```

```cpp
template < template<typename, typename> typename ... Tx>
class Myclass {};

int main ()
{
  using namespace std;

  Myclass <vector> x;
  Myclass <vector, list> y;
  Myclass <vector, list, deque, vector, list> z;
}
```
@01:26

```cpp
template < template<typename, typename> typename ... Tx>
class Myclass {};

int main ()
{
  using namespace std;

  Myclass <vector, map> x; // Invalid
}
```
Yukaridaki ornek invalid, `map` kullanamayiz. Cunku parametrik yapisi uygun degil. (Bunu derleyicide denedigimde hata vermedi, hocaya sor!) 28. Derste duzeltme yapildi.

Hocanin cevabi:

https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0522r0.html
Bu sonradan kabul edildi. Varsayılan template argüman alması durumu geçerli kılıyor.

```cpp
template <typename, typename, typename>
class Nec {};

template <typename, typename, typename = int>
class Erg {};

template <template<typename, typename> class>
class Myclass {  };

//Myclass<Nec> x; //gecersiz
Myclass<Erg> y; //gecerli
```


Ben template parametre paketindeki parametreleri nasil kullanacagim?

```cpp
template <typename ...Ts> // Ts Template Type Parametre Paketi
void foo(Ts ...args);     // args Fonksiyon parametre paketi
```

### *Compile Time Recursivity* -> *Pack Expansion* kisaca bahsedildi

```cpp
template <typename ...Ts>
class Myclass
{
  void func()
  {
    std::tuple<Ts...> x; // Pack expansion
  }
};
```

```cpp
class A {};
class B {};
class C {};

template <typename ...Ts>
class Myclass : puplic Ts...
{

};

int main ()
{
  /* 
  class Myclass : public A, public B, public C {
  };

  Derleyici yukaridaki gibi bir specialization kodu yazar.
  */
  Myclass <A, B, C> x;

  return 0;
}
```

templates with parameter packs:
  pack expansion
  fold expression


> Her *Template Id* bir *Template Specialization* olmak zorunda degildir.

> *Template Argument* baska, *Template Explicit* Argument baska. Karistirma.

> C++17 oncesinde *argument deduction* sadece fonksiyon template'leri icin vardi.

> Default template parameter olmaz, default template argument olur!

Templatelere yapilan gevsetmelere ornek:

```cpp
template < typename T>
void foo(T x)
{
  /*
  Template parametresine bagli bir turden(Dependent Type) bahsettigimiz
  icin `typename` kullanilmak zorunda. Ancak C++20 ile bu 
  zorunluluk kalkti.

  T::value_type y{}; // Valid Since C++20
   */
  typename T::value_type y{};
}
```

@01:51
### *Template Argument Deduction*'da Error Turleri

```cpp
template <typename T>
void foo(T, T&&);

int main
{
  int x = 5;
  foo(x, x); //int int& invalid
}
```

```cpp
template < typename T>
void foo(T, T);

template < typename T>
void bar (T&, T&) ;

int main()
{
  foo("ali", "ayse");
  bar ("can", "nur");
  bar("ali", "mert"); // Invalid: (const char[4], const char [5])
}
```
---
@01:57
Policy based design konusunda kullanilan bir teknik.
```cpp
#include <vector>
#include <iostream>
#include <list>

template < typename T, typename A, template<typename, typename>typename Con>
void func (const Con<T, A>& con) ;
int main()
{
  std:: vector<int> ive;
  std:: list<int> ilist;
  func(ivec);
  func (ilist);
}
```
> Argument deductionda genel mantik, argumandan parametre degiskenine aktarim olursa, parametre degiskeninin turu ne olmali.

```cpp
template < typename T, std::size_t N, std::size_t M›
void func(T(&)[N][M]);

int main()
{
  int a[5][20];
  //int [5][20]
  func(a);
}
```

```cpp
template < typename T, typename U>
T foo(U ux);

int main()
{
  int (*fp1) (double) = foo; // int foo<int, double>(double)
  float (*fp2) (float) = foo; // float foo<float, float>(float)
}
```

```cpp
template<typename T>
void f1(T*);

template<typename E, int N>
void f2(E(&)[N]);

template<typename T1, typename T2, typename T3>
void f3(T1 (T2::*)(T3*));

class S {
public:
void f(double*);
};

void g(int*** ppp)
{
  bool b[42]; // bool[42]
  f1(ppp); // deduces T to be int**
  f2(b); 11 deduces E to be bool and N toybe 42
  f3(&S::f); // deduces T1 = void, T2 = S, and T3 = double
}
```

@02:12

```cpp
template <typename T>
class Myclass {
public:
void foo(T x); // Template func degil. Temploid (Programcilarin uydurdugu bir terim.)
void bar(int x);
};

int main()
{
  Myclass<double> x;
  x.foo(12); // Cikarim yapilmayacak!
}
```

```cpp
template <typename T>
class Myclass {
public:
  void foo(T&&); // Universal ref degil! R val ref.
};
```

```cpp
template <typename T>
class Myclass {
public:
  template <typename U>
  void foo(U&&); // Bu template ve universal ref.
};
```

```cpp
template <typename T>
void func(T = 0);

class Myclass {};

int main()
{
  int x{20};

  func(20); //T is int
  func(2.0); //T is double
  func(&x); //T is int*
  //func(); // invalid: Default arguman yoluyla cikarim mekanizmasi yok.
  func(Myclass{}); //valid
  // func<Myclass>(); //invalid
}
```

> Asagidaki kod, instatiation'un nasil yapildigini anlamadigimizda yardimci olacak bir teknik. Scott Mayers'in buldugu bir yontem.

```cpp
template <typename>
class TypeTeller;

template <typename T>
void foo(T)
{
  TypeTeller<T> x;
}
int main()
{
  foo(4);
}
```

@02:30
> Template argument deduction ile, auto type deduction ayni kurallara tabi. Tek fark `initializer_list` icin olur. `initializer_list` yoluyla, template parametresi icin cikarim yapilamaz.


