## *Generic Programming Paradigmasina Yonelik Teknikler*

### *SFINAE (Substitution Error Is Not An Error)*

> *C++20* ile gelen *Concepts* *SFINAE* icin bir alternatiftir. *SFINAE*'in yerine daha kolay okunur ve yazilir. *SFINAE* kullanilan heryerde *Concepts* kullanilabilir.

> *Generic Programming Paradigmasi*'nda onemli bir problem var:
> - Template constraint edilmesi. Kisitlanmasi.
>    - static_assert declaration
>    - SFINAE
>    - concepts
> - Derleme zamaninda kod secimi.
>   - tag dispatch
>   - SFINAE
>   - `if constexpr`
>   - concepts
>   - function templates
>     - explicit specializaiton
>     - overload edilmesi
>   - class templates
>     - explicit specialization
>     - partial specialization

> Fonksiyon sablonlarinda *Partial Specialization* yok. Sinif sablonlarinda da *overloading* yok. @00:10.

#### **Substitution nedir?**

> Anlasilmasi icin su sira cok onemli:
> 1. Template aruman ya da argumanlarinin belirlenmesi. *Template Argument Deduction* ya da explicit arguman. Yani template argumanlarinin cikariminin yapilmasi. Cikarimin yapilmasi icin Explicit Template Argumani kullanilmiyor olmasi gerekir.
> 2. *Substitution* yapilmasi. *SFINAE* varsa, ilgili template-id overload setten cikartilir. Cikardiktan sonra viable olan baska bir overload yoksa sentaks hatasi olur.
> 3. Instatiation.


> ***Substitution'da failure olmasi ne demek?*** Hemen her zaman, substitution sirasindaki *nested-type*'lar ile ilgili.

```cpp
template <typename T>
typename T::value_type foo(T x);

int main()
{
  foo(12); // Invalid. Template argumani int'in value_type'i yok, dolayisiyla substitution hatasi.
}
```

```cpp
template <typename T>
typename T::value_type foo(T x);

struct Nec { using value_type = int; };
struct Efe { };
struct Berat { };

int main()
{
  foo(Nec{}); // Valid.
  foo(Efe{}); // Invalid.
  foo(Berat{}); // Invalid.
}
```

> Burada alinacak derleyici hatasi nedir? Yazilimcilar genelde "int'in value_type'i yoktur." seklinde bir mesaj alacaklarini zanneder. Dogrusu `foo: no matching overloaded fucntion found`. Yani bu cagriya karsilik bir `foo` fonksiyonu yok. Derleyici substitution asamasinda bir hata ile karsilasirsa, hard error vermek yerine; o *tamplate id*'ye sahip fonksiyonu *overload set*'ten cikartiyor.

```cpp
template <typename T>
typename T::value_type foo(T x);

void foo(double);

int main()
{
  foo(1);
}
```

> *Overload-set*'te olmamasi ne demek? Yukaridaki fonksiyonda sentaks hatasi yok. Normalde 2 tane overload olmasi lazim,
> template'ten olusturulacak template-id'ye iliskin overload, digeri gercek fonksiyon. Sentaks hatasi olmama sebebi,
>  once template uzerinden bir substitution yapilmaya calisildi, SF oldu overload setten cikti. Overload sette geriye kalan
> `void foo(double)` fonksiyonu oldu.

#### Ornekler:

```cpp
#include <iostream>
#include <vector>

template<typename T, unsigned N>
std::size_t len(T(&)[N])
{
	// std::cout << ("T(&)[N]\n");
	return N;
}

template<typename T>
typename T::size_type len(const T& t)
{
	// std::cout << ("const T&\n");
	return t.size();
}

/* 
  Template argumani olarak gonderilen turun size_type'i yoksa
  yukaridaki template'lerden ikincisi SFINAE-out edilir.
*/

int main()
{
	int a[10]{};
	std::cout << len(a) << '\n'; // 2. template secilse idi T turu const int[10] olurdu. T turunun size_type'i olmadigi icin SFINAE-out.
	std::cout << len("tmp") << '\n';
	int* p{};
	//std::cout << len(p) << '\n'; //invalid

  std::allocator<int>::size_type;
	std::allocator<int> x;
	//std::cout << len(x) << '\n'; //invalid. Buradaki hata substitutionda degil, instatiation asamasinda. size isimli member func yok.
	std::vector<int> ivec;
	std::cout << len(ivec) << '\n';
}
```
@00:37
```cpp
#include <vector>

template<typename T, unsigned N>
T* Begin(T(&array)[N])
{
	return array;
}

template<typename Container>
typename Container::iterator Begin(Container& c)
{
	return c.begin();
}

struct NecCon {
  using iterator = int*;
}

int main()
{
	std::vector<int> vec;
	int ar[10]{};
	Begin(vec); 
	Begin(ar);
  
  Begin(NecCon{}); // Invalid. Sebebi 1. template SFINAE-out, ama 2. template viable ve instantiation failure oldu.
}
```

@00:41

> ***Case Study***:
> - func fonksiyon parametresi olmayan bir fonksiyon sablonu olmali
> - fonksiyon sablonunun nontype int template parametresi olmali
> - ancak template argÃ¼mani olan tam sayi degerinin cift sayi olmasi veya tek sayi olmasina gore farkli overloadlar kullanilmali.
> - *static if* kullanilmamali

> Cozum 1: *Tag Dispatch* ile:
> ***Tag Dispatch ne demek?*** Benim cagirdigim fonksiyon bir baska implementasyon olarak kullanilacak fonksiyona cagri yapacak,
> o overload edilecek ve onun hangi overload'unun secilecegine gonderdigim tag karar verecek.

```cpp
#include <type_traits>

/* 
  using true_type = std::integral_constant<bool, true>;
  using false_type = std::integral_constant<bool, false>;
*/

void func_impl(std::true_type)
{
  std::cout << "For even numbers\n";
}

void func_impl(std::false_type)
{
  std::cout << "For odd numbers\n";
}

template <int I>
void func()
{
  func_impl(std::integral_constant<bool, (I % 2 == 0)>{});
}

int main()
{
  func<14>();
  func<3>();
}
```
> Tag Dispatch'te genel konvensiyon, `_impl`'ler hep `details` isimli *Nested Namespace*'e konur.


```cpp
#include <type_traits>
#include <iterator>
#include <vector>
#include <list>

template <typename InIter, typename Distance>
void Advance_impl(InIter& it, Distance n, std::input_iterator_tag)
{
  std::cout << "input_iterator\n";
  while (n--)
    ++it;
}

template <typename InIter, typename Distance>
void Advance_impl(InIter& it, Distance n, std::bidirectional_iterator_tag)
{
  std::cout << "bidirectional_iterator\n";
  if (n > 0)
    while (n--) ++it;
  else
    while (n++ < 0) --it;
}

template <typename InIter, typename Distance>
void Advance_impl(InIter& it, Distance n, std::random_access_iterator_tag)
{
  std::cout << "random_access_iterator\n";
  it += n;
}

template<typename Iter, typename Distance>
void Advance(Iter& it, Distance n)
{
  using category = typename std::iterator_traits<Iter>::iterator_category;
  /* 
    @01:07
    using category = typename std::Iter::iterator_category;
    Neden bu sekilde degilde, yukaridaki gibi?
    Bu sekilde kullanirsak, raw pointerlar icin fonksiyon cover
    edilemiyor. Raw pointer icin argumani icin ::iterator_category
    SFINAE-out olmasina sebep olur.

    template <typename Iter>
    struct IteratorTraits {
      using iterator_category = typename Iter::iterator_category;
    };
    
    template <typename T>
    struct IteratorTraits<T*> {
      using iterator_category = std::random_access_iterator;
    };
  */

  Advance_impl(it, n, category{});
}

int main()
{
  using namespace std;
  vector ivec{1, 3, 5, 7, 9, 11};
  list ilist{1, 3, 5, 7, 9, 11};
  /*    
    advance'in ilk parametresi bir iterator, ikinci parametresi tamsayi. Iteratoru tam sayi kadar arttiriyor.
  */
  std::advance()

  auto iter = ivec.end();
  cout << *iter << '\n';
  Advance(iter, 3);
  cout << *iter << '\n';

  auto liter = ilist.end();
  Advance(liter, 3);
}
```

@01:15
```cpp
#include <iostream>

template <typename T>
void f(const T& t, typename T::iterator* it = nullptr)
{
	std::cout << "template\n";
}

void f(...)
{
	std::cout << "variadic\n";
}


#include <vector>

int main()
{
  std::vector<int> ivec;

  /* 
    Burada 1. template ve 2. template viable.
    Ancak 1. daha spesifik oldugu icin, 1. secilecek.
  */
	f(ivec);
  /* 
    Burada int turunun ::iterator nested type'i olmadigi icin
    1. template SFINAE-out olur. 2. secilir.  
  */
	f(12);
}
```

@01:19
> Tek cift problemi icin SFINAE ile cozum.
```cpp
#include <iostream>

template <int I>
void func(char (*)[I % 2 == 0] = nullptr)
{
  std::cout << "For even number template arg\n";
}

template <int I>
void func(char (*)[I % 2 == 1] = nullptr)
{
  std::cout << "For odd number template arg\n";
}

/* 
  Burada da SFINAE-out mekanizmasi calisir, hard error olmaz.
*/

int main()
{
  func<12>();
  func<13>();
}
```

```cpp

template <bool B, typename T = void>
struct EnableIf {};

template <typename T>
struct EnableIf <true, T> {
  using type = T;
};

int main ()
{
  EnableIf<true, int>::type; // Valid, turu int.
  EnableIf<false, int>::type; // Invalid, sentaks hatasi.
}
```

> Istenilen, tam sayilar icin bu template kullanilsin.
> Ama tam sayi turleri degilse overload-set'ten cikartilsin. 

```cpp
#include <type_traits>

template < typename T, typename = std::enable_if< std::is_integral_v< T > >::type >
void func (T x);

int main ()
{
  func(1); // Valid.
  func(1.2); // Invalid
}
```

```cpp
template <bool B, typename T = void>
struct EnableIf {};

template <typename T>
struct EnableIf <true, T> {
  using type = T;
};

template <bool B, typename T = void>
using EnableIt_t = typename EnableIf<B, T>::type;

int main ()
{
  EnableIf<true, int>::type; // Valid, turu int.
  EnableIf<false, int>::type; // Invalid, sentaks hatasi.
}
```
```cpp
#include <type_traits>

template < typename T, typename = std::enable_if_t< std::is_integral_v< T > >>
void func (T x);

int main ()
{
  func(1); // Valid.
  func(1.2); // Invalid
}
```

> Hangi yollarla SFINAE yapilir:
> - Template parametresine varsayilan tur argumani vermek.
> - Fonksiyonun geri donus degeri turu.
> - Fonksiyonun parametre degiskenine varsayilan arguman vermek.

```cpp
#include <type_traits>

template <typename T>
std::enable_if_t<std::is_integral_v<T>>
foo(T)
{
  std::cout << "Integral type\n";
}

void foo(double)
{
  std::cout << "foo(double)\n";
}
```

```cpp
#include <type_traits>

template <typename T>
std::enable_if_t<std::is_integral_v<T>, T>
func(T)
{
  std::cout << "Integral type\n";
  return t;
}

template <typename T>
std::enable_if_t<!std::is_integral_v<T>, T>
func(T t)
{
  std::cout << "Not Integral type\n";
  return t;
}

int main ()
{
  func(3);
  func(3.5);
}
```

> Bir fonksiyon istiyorum ki geri donus turu `x+y` olsun.
```cpp
template <typename T, typename U>
auto func (T x, U y) -> decltype (x + y)
{

}
```

- Geri donus degeri turu ile SFINAE ornegi:

```cpp
#include <type_traits>

template <typename T>
auto foo(T)
-> typename std::enable_if_t<std::is_integral_v<T>>
{
  std::cout << "Integer types\n";
}

template <typename T>
auto foo(T)
-> typename std::enable_if_t<std::is_floating_point_v<T>>
{
  std::cout << "Floating types\n";
}

int main()
{
  foo(1);
  foo(1.);
}
```

> 2'inci ve 3'uncu teknigin avantaji, geri donus degeri dilediginiz gibi secilebilir. `enable_if`'in type'i ile ilgisi olmasina gerek yok.

- Fonksiyonun parametre degiskenine varsayilan arguman vererek SFINAE ornegi
```cpp
template <typename T>
void foo(T x, typename std::enable_if_t<std::is_pointer_v<T>> * = std::nullpointer)
{

}

// yalnizca pointer turleri icin
int main ()
{
  foo(12);
  foo(1.2);
}
```

> Template parametresine varsayilan tur argumani verme ornegi:
```cpp
template <typename T, typename = std::enable_if_t<std::is_floating_point_v<T>>>
void foo(T x);

int main()
{
  foo(23)
}
```

@02:07
### *Detection Idiom*

> Kisitlama bir sinif turunun bir fonksiyona sahip olup olmadigini test etmek.

```cpp
template <typename T>
auto func(T x) -> decltype(x.foo(), void())
{
  std::cout << "yes, has member function foo\n";
}

template <typename T>
auto func(T x) -> decltype(x.bar(), void())
{
  std::cout << "yes, has member function bar\n";
}

struct Furkan
{
  void foo();
};

struct Berat
{
  void bar();
};

int main()
{
  func(13);
  func(Furkan {});
  func(Berat {});
}
```
@02:14
```cpp
template <class T>
auto Begin(T& c) -> decltype(c.begin()) 
{
    return c.begin();
}

template <class T, size_t N>
T* Begin(T(&arr)[N]) 
{
    return arr; 
}


#include <vector>

int main()
{

    int ar[10]{};
    std::vector<int> ivec;

    auto p = Begin(ar); 
    auto iter = Begin(ivec); 
}
```

@02:15
#### `void_t` (Walter Brown'in Onerisi)

```cpp
template <typename ...Ts>
using void_t = void;

int main()
{
  void_t<int>;
}
```

> Derleme zamaninda bir turun foo isimli bir fonksiyonu
> olup olmadigini sinayan has_foo isimli bir trait yazin.

```cpp
/* 
  Burada 2. template parametresi, daha sonra sirf
  partial specialization yapabilmek icin kullaniliyor.
*/
template <typename T, typename = void>
struct has_foo_member : std::false_type {};

template <typename T>
struct has_foo_member<T, std::void_t<decltype(T{}.foo())>> {};

struct Nec {};
struct Erg {void foo(); };

int main()
{
  has_foo_member<int>::value;
}
```

```cpp
template <typename T, typename = void>
struct has_value_type_member : std::false_type {};

template <typename T>
struct has_value_type_member<T, std::void_t<typename T::value_type>> {};

struct Nec {};
struct Erg {void foo(); };

int main()
{
  has_foo_member<int>::value;
}
```

```cpp
#include <type_traits>

template<typename T, typename = void>
struct has_type_member : std::false_type {};

template<typename T>
struct has_type_member<T, std::void_t<typename T::type>> : std::true_type {};


template<typename T>
bool constexpr has_type_member_v = has_type_member<T>::value;

struct A {};
struct B { typedef int type; };

template <typename T, typename = std::enable_if_t<has_type_member_v<T>>>
void foo(T x);

int main()
{
	constexpr auto ba = has_type_member_v<A>;
	constexpr auto bb = has_type_member_v<B>;
	//foo(A{}); //error
	foo(B{});
}
```

```cpp
template <typename T, typename = void>
struct has_foo_member : std::false_type {};

template <T>
struct has_foo_member <T, std::void_t <decltype(T().foo())>> : std::true_type {};

// template <T>
// struct has_foo_member <T, std::void_t <decltype(declval<T>().foo())>> : std::true_type {};

/* 
  Buradaki T() ifadesi problem yaratir. Bu ifadenin
  kullanilabilmesi icin T turu default constructable olmali.
*/

struct A { void foo(); };
struct B {};

int main()
{
  has_foo_member<A>::value;
  has_foo_member<B>::value;
}
```

> Simdi bizim oyle bir ifadeye ihtiyacimiz var ki, default ctor olsa da olmasa da
> T turunden bir nesnenin foo fonksiyonunu cagirma ifadesini olusturacagim ama bu
> yine gecerli olmali. Bunun icin `declval` sablonu olusturuldu.

- Detayli anlatilmadi sonraki derse birakildi!

```cpp
template <typename T>
std::add_rvalue_reference_t<T> declval();

int main()
{
  
}
```

### Tag dispatch (Baslik yukari tasinmali! SFINAE baslanip Tag Dispatch'e girilip, SFINAE'e geri donuldu.)
