## Move ctor'un noexcept olmasi durumu:
- Move ctor `noexcept` olarak tanimlanmaz ise, vector sinifi realloc yaptiginda move yerine copy ctor'u cagirir.

[Ornek](https://godbolt.org/z/acWq1qjhz)
[Benchmark](https://godbolt.org/z/vPc8qr358)

> Ek bilgi: *Promise no less, require no more. Liscov Substitution Principle, inheritence'da gecerli* kural.

@00.39
> Bir fonksiyon `noexcept` garantisi verip, run-time'da exception throw ederse dogrudan terminate cagrilir. Dtor'un noexcept olmama ihtimali yok.

`noexcept` olmasi beklenen fonksiyonlar:
- move ctor.
- move assignment.
- swap functions.
- Memory deallocation functions. (`delete`)

@00:49
## Copy elision
 - Elision -> elide kokunden. Bir seyin yapilmamasi manasinda.
 - Ister mandatory olsun ister derleyici optimizasyon olsun copy elision, nesne olusturmakla ilgili.

> C++17 oncesinde hicbir copy elision dilin standardi garantisi altinda degildi. C++17 standardi ile bazi garantiler geldi. Onceki standartlarda derleyici optimizasyonu seklindeydi. Buna ragmen move ctor ve copy ctor'un cagrilabilir olmasi zorunluydu. Standartlasmasi bu zorunlulugu ortadan kaldirmistir.

@00.55
## Mandatory copy elision.
 ```cpp
 Myclass{}
 ```

 > Modern C++ oncesinde bu bir nesne statusunde idi. C++17 sonrasindan itibaren bir PR value expression'in kendisi bir nesneye karsilik gelmiyor. Bunun bir nesne sayilabilmesi icin bazi kosullarin saglanmasi gerekiyor. Belirli bir context icinde kullanilmasi lazim.

 **C++17 ile PR value ifadelerin nesne sayilabilmesi kosullari:**
 - PR value olan bir sinif nesnesi ifadesinin, sinif nesnesi haline gelmesi icin X value'ya donusmesi gerekiyor. Bu duruma standart; *Temporary Materialization* diyor.

> Copy elision optimizasyonu dilin as-if rule'u cignedigi anlamina geliyor.

 ```cpp
#include <iostream>
#include <string>

class Myclass {
public:

Myclass () { std::cout << "Default ctor\n"; }

Myclass (const Myclass&) = delete;
Myclass& operator= (const Myclass&) = delete;
};

void foo(Myclass) { }

Myclass bar() { return Myclass{}; }

Myclass baz() { return bar(); }

int main()
{
    foo(Myclass{Myclass{Myclass{Myclass{}}}});

    auto m = Myclass{Myclass{baz()}}; 
}
 ```

 ```cpp
#include <iostream>
#include <string>

class Myclass {
public:

Myclass () { std::cout << "Default ctor\n"; }

Myclass (const Myclass&) = delete;
Myclass& operator= (const Myclass&) = delete;
};

Myclass foo()
{
    return Myclass{};
}

int main()
{
    Myclass m = foo();
}
 ```

 *Unmterialized Object Passing*

@01:23

**Fabrika fonksiyonu**
- make_unique implementasyonu
```cpp
#include <memory>
#include <string>

template <typename T, typename ...Ts>
std::unique_ptr<T> makeUnique(Ts&& ...args)
{
    return std::unique_ptr<T>(new T(std::forward<Ts>(args)...));
}

int main ()
{
    using namespace std;
    unique_ptr<string > uptr(new string (100, 'a'));
    auto uptr2 = makeUnique<string>(100, 'a');
}
```

`throw MyError{};` Yandaki ifade de PR value oldugu icin mandatory copy elision.

@01.35
## Named Return Value Optimization (NRVO)
- Mandatory degil.
- Derleyicinin optimizasyon switchleri ile acilip kapatilabilir.
- copy / move ctor cagrilabilir olmali.
- Her durumda cagrilamiyor.
- Derleyiciye bagli, derleyiciden derleyiciye degisiyor.

### NRVO'nun yapilamadigi durumlar
- Pessimistic move

@02:00?
## Moved from state
> Bir nesnenin kaynagini cagirdiktan sonra, o nesnenin hala kullanilabilir durumda olmasi.

> Standart kutuphane diyor ki *moved state*'teki bir nesne destructible olmali.

> Standart kutuphane diyor ki *moved state*'teki bir nesne valid bir state'te. Demek oluyor ki, nesnenin invariantlari arasinda tutarli olmali.

@02:20
> Standart kutuphane, moved from state'teki containerlar (`vector, list, deque`) icin empty state'tedir demiyor. Ancak bunun tersini aksi kilacak bir implementasyon yapmak mumkun degil. Yani moved from state'teki containerlarin empty olmasina guvenebilirsiniz. Stringler icin bu durum biraz farkli, small string optimization sebepli.
