```cpp
#include <iostream>

template <typename T, typename U>
struct Nec 
{
    Nec ()
    {
        std::cout < "primary template\n";
    }
};

template <typename T>
struct Nec<T, voids>
Nec ()
{
    std::cout < "partial specialization\n";
};

int main()
{
    Nec<int, double> n1;
    Nec<int, void> n2;
}
```

```cpp
#include <type_traits>

template <class T, class = void>
struct has_foo_member : std::false_type {};

template <class T>
struct has_foo_member<T, std::void_t<decltype(std::declval<T>().foo())>> : std::true_type {};


template <typename T, typename U = void>
constexpr bool has_foo_member_v = has_foo_member<T, U>::value;


struct A {};
struct B { int foo(); };

int main()
{
	constexpr auto x = has_foo_member_v<A>;
}
```

```cpp
#include <type_traits>

template< class, typename = void >
struct is_pre_incrementable : std::false_type { };


template< class T >
struct is_pre_incrementable<T, std::void_t
									<
									decltype(++std::declval<T&>())
									>
							   > : std::true_type { };

template<typename T>
constexpr bool is_pre_incrementable_v = is_pre_incrementable<T>::value;

struct A {};
struct B {
	B& operator++();
};

int main()
{
	constexpr auto b1 = is_pre_incrementable_v<int>;  //true
	constexpr auto b2 = is_pre_incrementable_v<A>;  //false
	constexpr auto b3 = is_pre_incrementable_v<B>;  //false
}
```

@00:25
### `declval`

```cpp
template <typename T>
std::add_rvalue_reference_t<T> Declval()noexcept;

template <typename T>
auto foo(T ) -> decltype(Declval<T>.foo())
{

}

```
> Eger sizin bir template parametreniz varsa, diyelim ki `T`. Bu turden bir nesnenin; uye fonksiyonuna veya data-member'ina
> erisme ifadesi kullanacaksaniz `T().foo()` seklinde bir ifade kullanmak gerekir. Ama `T` turu default constructable
> olmayabilir.

@00:30
## STL'de Container Olusturmanin Makro Olcekte Incelenmesi

```cpp
#include <type_traits>

template <typename, typename = void>
struct is_container : std::false_type {};

template <typename T>
struct is_container<T,
	std::void_t<
	typename T::size_type,
	typename T::value_type,
	typename T::iterator,
	typename T::const_iterator,
	decltype(std::declval<T>().size()),
	decltype(std::declval<T>().begin()),
	decltype(std::declval<T>().end())>>
	: std::true_type{};

template <typename T, typename U = void>
constexpr bool is_container_v = is_container<T, U>::value;
		
struct X {};

#include <list>

struct Nec {
    using value_type = int;
    using size_type = unsigned int;
    using iterator = int*;
    using const_iterator = const int*;
    int size() const;
    int* begin() const;
    int* end ()const;
} ;

//static_assert(is_container_v<A>);
static_assert(is_container_v<std::list<int>>);
```

@00:45
## Tag Dispatch Hatirlatma

```cpp
#include <iostreamâ€º
#include < type_traits>

template < typename T>
void foo_impl(T value, std:: true_type)
{
    std:: cout << "Integral version: " << value << '\n';
}
template < typename T>
void foo_impl(T value, std:: false_type)
{
    std:: cout << "Non-integral version: " << value << '\n';
}

template <typename T>
void foo(T value)
{
    foo_impl(value, std::is_integral<T>{});
}

int main()
{
    foo(12);
    foo(1.2);
}
```

```cpp
int main()
{
    constexpr auto x = std::integral_constant<int, 5> {} + std::integral_constant<int, 3>{};
    // constexpr auto x = std::integral_constant<int, 5> {}.operator int() + std::integral_constant<int, 3>{}.operator int();

    /* 
    integral_constant turunun:
        - Tur donusturmeye konu olacak bir baglamda cagrilirsa, tur donusturme operator fonksiyonu cagrilir.
        - Fonksiyon cagri operatorunun operandi olursa, o zaman da fonksiyon cagri operatoru cagrilir
    
    */
}
```

```cpp
template <typename T, T VAL>
struct IntegralConstant {
    static constexpr T value = VAL;
    using value_type = T;
    
    operator T() const noexcept
    {
        return VAL;
    }

    T operator()() const noexcept
    {
        return VAL;
    }
}
```

```cpp
/* 
    Tag-dispatch orneginin SFINA ile implementasyonu
*/

#include < type_traits >

template <typename T>
std: :enable_if_t<std::is_integral_v<T>>
foo(T value)
{
    std::cout << "Integral version: " << value << '\n';
}

template < typename T>
std::enable_if_t<!sta::is_integral_v<T>>
foo(T value) {
    std::cout << "Non-integral version: " << value << '\n';
}
```

```cpp
#include <type_traits>

template<typename T>
void foo(T)
{
    if constexpr (std::is_integral_v<T>) {
        //
    }
    else {
        //
    }
}
```

```cpp
// Tag-dispatch
#include <type_traits>

template<typename T>
T abs_impl(T x, std::false_type) 
{
    return (x < 0) ? -x : x;
}

template<typename T>
T abs_impl(T x, std::true_type) 
{
    return x;
}

template<typename T>
T abs_value(T x) 
{
    return abs_impl(x, std::is_unsigned<T>{});
}
```
@01:01
```cpp
/* 
    class Nec {
    public:
        Nec(); //constructs the object x-way
        Nec(); //constructs the object z-way //error
    }; 
*/

/* 
    class Nec
    {
    public:
        struct ctor_x_way{};
        struct ctor_y_way{};

        explicit Nec(ctor_x_way);
        explicit Nec(ctor_y_way);
        //...
    };

    int main()
    {
        //Nec nx(Nec::ctor_x_way());  most vexing parse
        Nec nx{ Nec::ctor_x_way{} };
        Nec ny{ Nec::ctor_y_way{} };
    }
*/

#include <iostream>

class Nec
{
public:
    constexpr static struct ctor_x_way{}x_way;
    constexpr static struct ctor_y_way{}y_way;

    explicit Nec(ctor_x_way);

    explicit Nec(ctor_y_way);
    //...
};

int main()
{
    Nec nx{ Nec::x_way};
    Nec ny{ Nec::y_way};    
}
```

@01:06
> 25.Dersteki hatali kisim duzeltildi.

```cpp
template <typename, typename>
class Nec {};

template <typename, typename, typename>
class Erg {};

template <typename, typename, typename = int>
class Cin {};

template <template<typename, typename> class X>
class Myclass {

};

int main()
{
    Myclass <Nec> x; // Valid
    Myclass <Erg> x; // Invalid
    Myclass <Cin> x; // Valid
}
```

```cpp
#include <vector>
#include <list>
#include <map>

template <typename ...Ts>
class A{};

template <int ...VALS>
class B{};

template <template<typename, typename>class ...Ts>
class C{};

int main()
{
    using namespace std;

    C<vector, list> c1; // Valid
    /* 
        Duzeltme: Asagidaki ornek gecersiz denmisti, ancak standartta yapilan bir degisiklik ile gecerli.
    */
    C<vector, list, map> c1; // Valid
}
```


@01:13
## `static_assert` Kullanimi

> *Assertion* -> Dogrulama

> Programlama hatalarini bulmaya yonelik arac seti.

> Hatalar 2 ayriliyor:
> - Run time hatalari.
> - Kodlama hatalari(Programming error).

> Kodlama hatalari ile basa cikmak icin *assertion* kullanilir.

> Assertionlar 2'ye ayrilir:
> - *Dynamic assertions (runtime assertions)*: Run time'da calisir, ornegin programin calisma zamaninda bir kosulun gerceklesip gerceklesmedigi test edilir. Bunun icin `assert` makrosu kullanilir.
> - *Static assertions (compile time assertions)*: 

```cpp
/* 
    C'de primitiv yontemlerle yapilan static assertion yontemleri
*/
int a[sizeof(int) == 4];

typedef int ar[sizeof(int) == 2]; // int[2]
```

```cpp
static_assert(sizeof(int) == 4, "sizeof int must be 4");
static_assert(sizeof(int) == 4); // C++17'e kadar 2. arguman zorunluydu. 
```

> `static_assert` declaration'in guzel kismi heryerde kullanilabiliyor;
> - namespace
> - fonksiyon icine
> - class definition icine 
> - ...

```cpp
template <typename T>
void foo(T x)
{
    static_assert(std::is_integral_v<T>, "Template argument must be integral type");
}
```

> Compile time'da instantiation asamasinda kontrol edilir. SFINAE ile karistirilmamali, substitution vs. yapilmis kod uretilmis.
> 'static_assert' kod secimi icin kullanilamaz. Sadece hata kontrolu icin. Yani SFINAE-out yapmaz.







## *Compile Time Recursivity*